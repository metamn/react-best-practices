import { Meta, Story, Preview } from "@storybook/addon-docs/blocks";

import GraphQL from "./GraphQL";

<Meta title="GraphQL" component={GraphQL} />

# GraphQL

GraphQL is a [reactive, functional](https://blog.danlew.net/2017/07/27/an-introduction-to-functional-reactive-programming/) approach to work with APIs. Using decoupling and composition achieves better results than its REST predecessor.


## Advantages over REST

```
|=========================================================================|
| Concept   | REST           | GraphQL   | Advantages over REST           | 
|===========|================|===========|================================|
| Core idea | Resource       | Type      | Data decoupled from operations |
|-----------|----------------|-----------|--------------------------------|
| Endpoints | URL Routes     | Schema    | Composable, nested queries     |
|-----------|----------------|-----------|--------------------------------|
| Code      | Route handlers | Resolvers | Composable functions           |
|=========================================================================|
```

### Resources vs Types

Data decoupled from operations.

```bash
# REST Resources
#
# GET is coupled with `books`
# - Always returns the same shape
# - The server controls the shape (returns `author` with fixed details)
#
GET /books/1  

{
  "title": "Black Hole Blues",
  "author": { 
    "firstName": "Janna",
    "lastName": "Levin"
  }
}
```

```bash
# GraphQL Types
#
# GET is not coupled with `books`. 
# - It can return anything else like `comments`
# - The client controls the shape (returns `author` with variable details)
# 
GET /graphql?query={ book(id: "1") { title, author { firstName } } }

{
  "title": "Black Hole Blues",
  "author": {
    "firstName": "Janna",
  }
}
```

```js
/**
 * GraphQL Types
 * 
 * - They can be of data type and operations type (Query, Mutation, Subscription)
 * - Operations can freely mix'n'match how to work with data  
 */

/**
 * Data
 */ 
type Book {
  id: ID
  title: String
  published: Date
  price: String
  author: Author
}

/**
 * Data
 */ 
type Author {
  id: ID
  firstName: String
  lastName: String
  books: [Book]
}

/**
 * Operation 
 */ 
type Query {
  book(id: ID!): Book
  author(id: ID!): Author
}
```

### URL Routes vs. Schema

Composable, nested queries served by a single endpoint.

```bash
# REST URL Routes / Endpoints
#
# - A list of multiple URLs
# - URLs can't be nested or composed. They can be called one-by-one

GET /books/:id
GET /authors/:id
GET /books/:id/comments
POST /books/:id/comments
```

```bash
# GraphQL Schema
#
# - A single URL endpoint handling both queries and writes

GET /graphql?query={...}
GET /graphql?mutation={...}
```

```js
/**
 * GraphQL Schema
 * 
 * - A single document containing both data and operation types
 * - It's attached to a single URL: `/graphql`
 * - Queries can be nested, composed
 */

type Book { ... }
type Author { ... }
type Comment { ... }
input AddCommentInput { ... }

/**
 * Composed, nested query
 */ 
type Query {
  book(id: ID!): Book
  author(id: ID!): Author
}

type Mutation {
  addComment(input: AddCommentInput): Comment
}
```

A strange thing might be to use `GET` instead of `POST` to modify data, as REST recommends.

In GraphQL:

> [...] technically any query could be implemented to cause a data write. However, it's useful to establish a convention that any operations that cause writes should be sent explicitly via a mutation. &mdash; via [Queries and Mutations](https://graphql.org/learn/queries/)

### Route Handlers vs. Resolvers

Composable resolvers to serve nested queries.

```js
/**
 * REST Route Handlers
 *
 * - A route handler is a Node.js function
 * - It handles the `GET /authors/:id` endpoint call and nothing more
 */
app.get('/authors', function (req, res) {
  const id = req.id
  const author = find(authors, { id: id })
  res.send(author)
}) 
```

```js
/**
 * GraphQL resolvers
 *
 * - A resolver is a JavaScript function.
 * - It handles a composed, nested call:
 * 
 * query {
  author(id: 1) {
    firstName
    books {
      title
    }
  }
}
 * 
 * - `books` has access to `author` which is a result of another resolver
 */
const resolvers = {
  Query: {
    author: (root, { id }) => find(authors, { id: id }),
  },
  Author: {
    books: (author) => filter(books, { authorId: author.id }),
  },
};  
```

### Archicetural advantage

- All clients connect to the same endpoint
- The endpoint is flexible vs. the old API versioning approach
- The underlying services can be mixed and matched into different variations

#### Before adopting a data graph
![Before adopting a data graph](graphql-1.png)

#### Experimenting with a Backend-For-Frontend, a pattern which mimics a data graph.
![Experimenting with a Backend-For-Frontend](graphql-2.png)

#### The move to one data graph
![The move to one data graph](graphql-3.png)

## GraphQL service providers

- The market [is very new](https://graphql.org/code/#services)
- Only a few players offer a trully GraphQL backend
- Even these services are not fully complete

An ideal GraphQL solution would offer the following features:

1. Visual Schema designer
2. Automatic database generation / provisioning / sync based on the schema
3. Automatic resolver generation where possible
4. Automatic lambda function generation / provisioning / sync for the resolvers
5. Automatic Type / Schema code generation and sync for various clients

### AWS AppSync with Amplify

Unless the 1. visual scheme designer it offers all the above features.

### Apollo

It's [less automated](https://www.apollographql.com/docs/tutorial/introduction/) than AWS. All features listed above must be implemented manually.

### Headless CMS

For small scale Headless CMS could be a solution. Unfortunately [only a few of them](https://docs.google.com/spreadsheets/d/1AmrfMT6a-tT9x4nR__RumuCcT6NedxliFf-76Ocv2pQ/edit?usp=sharing) offer GraphQL support (in their free plan).

#### TakeShape

- Works out of the box, it deploys the site to Netlify with a click.

#### GraphCMS

Unless 5. codegen it offers all the above features. However these features seems to be undocumented and very fragile.

#### Prismic

- GraphQL support has to be asked for / enabled manually by the support team


#### WPGraphQL

- Works out of the box
- However you'll have to stick to the basic data structure it offers
- Probably it can be extended with Advanced Custom Fields


## Resources

- [An Introduction to Functional Reactive Programming](https://blog.danlew.net/2017/07/27/an-introduction-to-functional-reactive-programming/)
- [GraphQL vs. REST](https://blog.apollographql.com/graphql-vs-rest-5d425123e34b)
- [Queries and Mutations](https://graphql.org/learn/queries/)
- [Expedia Group Transforms Product Development with Apollo](https://www.apollographql.com/customers/expediagroup/)
- [Start here to learn how to build fullstack apps with Apollo](https://www.apollographql.com/docs/tutorial/introduction/)
- [GraphQL Services](https://graphql.org/code/#services)
- [A list of developer friendly headless CMS services on JAMStack](https://docs.google.com/spreadsheets/d/1AmrfMT6a-tT9x4nR__RumuCcT6NedxliFf-76Ocv2pQ/edit?usp=sharing)