import { Meta, Story, Preview } from "@storybook/addon-docs/blocks";

import GraphQL from "./GraphQL";

<Meta title="GraphQL" component={GraphQL} />

# GraphQL

GraphQL is a reactive and functional approach to work with APIs. By using decoupling and composition achieves more flexible results than its REST predecessor.

## Different GraphQL service providers

### AWS AppSync with Amplify

1. Create API
- Enter name
2. Create Resources
- Enter manually the Type definition
```
## Enter a custom type name below as well as the fields it contains. 
## Fields can of the type String, Int, Float, Boolean, ID, and other custom types that you define.
## After defining your type, edit any resource details below such as adding a secondary index and press "Create".
type Post {
	id: ID!
	title: String!
	content: String!
}
```
3. Automatically get resolvers for resources: 
- All queries, mutations, subscriptions and filters, inputs
- Where is possible there is a way to attach custom resolvers
![AWS AppSync Resolvers](aws-appsync-1.png)
4. Automatically get DynamoDB tables
5. Automatically get API documentation via the Query explorer
6. `amplify codegen`: automatically generate GraphQL documents (JSON schema, queries, mutations, and subscriptions) and generate types for your JavaScript, TypeScript, or Flow application.
![AWS Amplify Codegen](aws-appsync-2.png)
7. If you want to connect resources (articles with authors) you'll have to write your own types (queries) and perhaps resolvers too

### Apollo

It's less automated than AWS. All [the following tasks](https://www.apollographql.com/docs/tutorial/introduction/) has to be done manually. No generators ...

1. Build a schema
2. Hook up your data sources
3. Write your graph's resolvers
4. Run your graph in production
5. Connect your API to a client


### Headless CMS

From the [list](https://docs.google.com/spreadsheets/d/1AmrfMT6a-tT9x4nR__RumuCcT6NedxliFf-76Ocv2pQ/edit?usp=sharing) the most populars with a free GraphQL tier are:

#### TakeShape

- Works fine, it deploys the site to Netlify with a click.
- https://api.takeshape.io/project/2336ee80-2e97-455e-b496-3d06d09efa1a/graphql
API KEY: c4d2cb04607d409da7c2b371e84a89fb

#### GraphCMS

1. Build visually you model / resources: https://graphcms.com/docs/getting-started/define-content-structure/
2. Automatically get some resolvers (they are visible only in the Query explorer)
3. Automatically get database tables
4. Automatically get API documentation via the Query explorer
5. That's all ... no docs, no codegen, no react integration

#### Prismic

- GraphQL support has to be asked for / enabled manually by the support team
- https://metamn.prismic.io/graphql


#### WPGraphQL

- Works out of the box
- However you'll have to stick to the basic data structure it offers
- Probably it can be extended with Advanced Custom Fields

## Advantages over REST

```
|=========================================================================================|
| Concept   | REST           | GraphQL   | Advantages over REST                           | 
|===========|================|===========|================================================|
| Core idea | Resource       | Type      | Shape decoupled from fetch                     |
|-----------|----------------|-----------|------------------------------------------------|
| Endpoints | URL Routes     | Schema    | Composable queries served by a single endpoint |
|-----------|----------------|-----------|------------------------------------------------|
| Code      | Route handlers | Resolvers | Composable resolvers to serve nested queries   |
|=========================================================================================|
```

### Resources vs Types

Shape decoupled from fetch.

```bash
# REST Resources
#
# GET is coupled with `books`
# - always returns the same result (shape)
# - the server controls the details ( returns `author`)
GET /books/1  

{
  "title": "Black Hole Blues",
  "author": { 
    "firstName": "Janna",
    "lastName": "Levin"
  }
  // ... more fields here
}
```

```bash
# GraphQL Types
#
# GET is not coupled with `books`
# - returns results of any shape
# - the client controls the details (return some `author` data) 
GET /graphql?query={ book(id: "1") { title, author { firstName } } }{
  "title": "Black Hole Blues",
  "author": {
    "firstName": "Janna",
  }
}
```

```js
/**
 * GraphQL Types
 * 
 * In order to control the details the client has to define its own needs.
 * Like:
 *  - The shape of the `book` and the `author`
 *  - The shape of the `query`
 * 
 * The real _decoupling_ is done by separating the two shape types: data and operations.
 * An operation can mix'n'match the data types in any ways.  
 */

/**
 * Data shape
 */ 
type Book {
  id: ID
  title: String
  published: Date
  price: String
  author: Author
}

/**
 * Data shape
 */ 
type Author {
  id: ID
  firstName: String
  lastName: String
  books: [Book]
}

/**
 * Operation shape
 * - There can be other similar types like Mutation, Subscription
 */ 
type Query {
  book(id: ID!): Book
  author(id: ID!): Author
}
```

### URL Routes vs. Schema

Composable queries served by a single endpoint.

```bash
# REST URL Routes / Endpoints
#
# It's a list of multiple URLs you can call one-by-one

GET /books/:id
GET /authors/:id
GET /books/:id/comments
POST /books/:id/comments
```

```js
/**
 * GraphQL Schema
 * 
 * A single document containing both data and operation types
 * It's attached to a single URL: `/graphql`
 * Queries can be nested, composed
 */

type Book { ... }
type Author { ... }
type Comment { ... }
input AddCommentInput { ... }

/**
 * Composed, nested query
 */ 
type Query {
  book(id: ID!): Book
  author(id: ID!): Author
}

type Mutation {
  addComment(input: AddCommentInput): Comment
}
```

```bash
# GraphQL endpoint
#
# A single URL endpoint handling both queries and writes

GET /graphql?query={...}
GET /graphql?mutation={...}
```

A strange thing might be the `GET /graphql?mutation=` line which uses `GET` instead of `POST` to modify data, as REST recommends.

In GraphQL:

> [...] technically any query could be implemented to cause a data write. However, it's useful to establish a convention that any operations that cause writes should be sent explicitly via a mutation. &mdash; via [Queries and Mutations](https://graphql.org/learn/queries/)

### Route Handlers vs. Resolvers

Composable resolvers to serve nested queries.

```js
/**
 * REST server side code (route handler) as a Node.js function
 * It handles the `GET /authors/:id` endpoint call
 */
app.get('/authors', function (req, res) {
  const id = req.id
  const author = find(authors, { id: id })
  res.send(author)
}) 
```

```js
/**
 * GraphQL resolvers
 * It handles a composed, nested call:
 * 
 * query {
  author(id: 1) {
    firstName
    posts {
      title
    }
  }
}
 */
const resolvers = {
  Query: {
    author: (root, { id }) => find(authors, { id: id }),
  },
  Author: {
    posts: (author) => filter(posts, { authorId: author.id }),
  },
};  
```

### Archicetural advantage

#### Before adopting a data graph
![Before adopting a data graph](graphql-1.png)

#### Experimenting with a Backend-For-Frontend
![Experimenting with a Backend-For-Frontend](graphql-2.png)

#### The move to one data graph
![The move to one data graph](graphql-3.png)


## Resources

- [GraphQL vs. REST](https://blog.apollographql.com/graphql-vs-rest-5d425123e34b)
- [Queries and Mutations](https://graphql.org/learn/queries/)
- [Expedia Group Transforms Product Development with Apollo](https://www.apollographql.com/customers/expediagroup/)
- [Start here to learn how to build fullstack apps with Apollo](https://www.apollographql.com/docs/tutorial/introduction/)
- [A list of developer friendly headless CMS services on JAMStack](https://docs.google.com/spreadsheets/d/1AmrfMT6a-tT9x4nR__RumuCcT6NedxliFf-76Ocv2pQ/edit?usp=sharing)