import { Meta, Story, Preview } from "@storybook/addon-docs/blocks";

import ThinkingInReact from "./ThinkingInReact";

<Meta title="ThinkingInReact" component={ThinkingInReact} />

# Thinking In React

Everything in React rolls around the concept of state.

In the past everything rolled around URLs. Requests were made to them and responses received. This was called AJAX, REST, CRUD, MVC and so forth. Now one has to [forget all these](https://kentcdodds.com/chats-with-kent-podcast/seasons/01/episodes/realigning-your-model-of-react-after-hooks-with-dan-abramov) to get the React way easier.

By definition, in React the software engineer has to:

> Design simple views for each state in your application, and React will efficiently update and render just the right components when your data changes. &mdash; via [Reactjs.org](https://reactjs.org/)

The keywords are design and state vs. update and render &mdash; synonims for request and response. Focus on the first two and the rest is solved elegantly by React.

Designing views for state is a new paradigm. It happens rather on the front-end than on the back-end. The user interface declares its needs and the back-end tries to serve it. In the old days the API, Model and Controller were first then the user interface was constructed around.

Using state to manage all kind of changes on the user interface &mdash; coming either from user interactions or from the underlying network and services infrastucture &mdash; is again a novel approach.

In the past there was no such mechanism at all. The user interface parts &mdash; data (API), content (HTML), presentation (CSS) and behavior (Javascript) &mdash; were massaged into a programmable whole in an ad-hoc way by using naming conventions (REST verbs and nouns, MVC folder structure, class names) and obscure methodologies like Atomic design, BEM, OOCSS, SMACSS &mdash; all proved to be impossible to scale.

Now React puts a mathematical model of computation &mdash; [finite-state machines](https://en.wikipedia.org/wiki/Finite-state_machine) &mdash; at its core. With that new perspectives open &mdash; from data-driven applications to autogenerated tests.

In a way React tries to replace the subjective, ad-hoc parts of designing and developing apps with a more scinetific and integrated approach.

## Resources

- [Realigning Your Model of React After Hooks - With Dan Abramov](https://kentcdodds.com/chats-with-kent-podcast/seasons/01/episodes/realigning-your-model-of-react-after-hooks-with-dan-abramov)
- [Finite-state machine](https://en.wikipedia.org/wiki/Finite-state_machine)
- [Write Fewer Tests! - From Automation to Autogeneration](https://slides.com/davidkhourshid/mbt#/)
- [Relay - A JavaScript framework for building data-driven React applications](https://relay.dev/)
- [Tomorrowww - Devices as designers](http://metamn.io/beat/tomorrowww/)
- [Thinking in React](https://reactjs.org/docs/thinking-in-react.html)
- [Understanding Information Architecture](https://prezi.com/aafmvya6bk7t/understanding-information-architecture/)
- [Functional reactive programming](https://hashnode.com/post/why-does-react-emphasize-on-unidirectional-data-flow-and-flux-architecture-ciibz8ej600n2j3xtxgc0n1f0)
- [State machines and statecharts for the modern web](https://xstate.js.org/)

---

[Home](./?path=/docs/home--storybookdocsonly)
